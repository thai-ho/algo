# DFS (Depth-First Search) - Complete Guide

## üîç ƒê·ªãnh nghƒ©a

**DFS (Depth-First Search)** l√† thu·∫≠t to√°n duy·ªát ƒë·ªì th·ªã/c√¢y theo chi·ªÅu s√¢u:

- ƒêi s√¢u ho√†n to√†n m·ªôt nh√°nh tr∆∞·ªõc khi chuy·ªÉn sang nh√°nh kh√°c
- S·ª≠ d·ª•ng Stack (ho·∫∑c Recursion) ƒë·ªÉ theo d√µi path
- Time: O(V + E), Space: O(V) v·ªõi V l√† vertices, E l√† edges

## üå≥ C·∫•u tr√∫c c∆° b·∫£n

### Recursive DFS:

```javascript
function dfs(node, visited) {
  if (!node || visited.has(node)) return;

  visited.add(node); // ƒê√°nh d·∫•u ƒë√£ visit
  console.log(node.value); // Process node

  // Duy·ªát t·∫•t c·∫£ neighbors
  for (let neighbor of node.neighbors) {
    dfs(neighbor, visited);
  }
}
```

### Iterative DFS:

```javascript
function dfsIterative(startNode) {
  const stack = [startNode];
  const visited = new Set();

  while (stack.length > 0) {
    const node = stack.pop();

    if (visited.has(node)) continue;
    visited.add(node);
    console.log(node.value);

    // Th√™m neighbors v√†o stack (ng∆∞·ª£c th·ª© t·ª±)
    for (let i = node.neighbors.length - 1; i >= 0; i--) {
      stack.push(node.neighbors[i]);
    }
  }
}
```

## üéØ C√°c tr∆∞·ªùng h·ª£p s·ª≠ d·ª•ng DFS

### 1. **Tree Traversal** - Duy·ªát c√¢y

```javascript
// Pre-order: Root ‚Üí Left ‚Üí Right
function preOrder(root) {
  if (!root) return;

  console.log(root.val); // Process root first
  preOrder(root.left); // Then left
  preOrder(root.right); // Then right
}

// In-order: Left ‚Üí Root ‚Üí Right
function inOrder(root) {
  if (!root) return;

  inOrder(root.left); // Left first
  console.log(root.val); // Then root
  inOrder(root.right); // Then right
}

// Post-order: Left ‚Üí Right ‚Üí Root
function postOrder(root) {
  if (!root) return;

  postOrder(root.left); // Left first
  postOrder(root.right); // Then right
  console.log(root.val); // Root last
}
```

### 2. **Path Finding** - T√¨m ƒë∆∞·ªùng ƒëi

```javascript
// T√¨m path t·ª´ start ƒë·∫øn target
function findPath(graph, start, target, path = [], visited = new Set()) {
  if (start === target) {
    return [...path, start];
  }

  if (visited.has(start)) return null;

  visited.add(start);
  path.push(start);

  for (let neighbor of graph[start]) {
    const result = findPath(graph, neighbor, target, path, visited);
    if (result) return result;
  }

  path.pop(); // Backtrack
  return null;
}

// T√¨m t·∫•t c·∫£ paths
function findAllPaths(graph, start, target, path = [], visited = new Set()) {
  if (start === target) {
    return [[...path, start]];
  }

  if (visited.has(start)) return [];

  visited.add(start);
  path.push(start);

  let allPaths = [];
  for (let neighbor of graph[start]) {
    const paths = findAllPaths(graph, neighbor, target, path, visited);
    allPaths.push(...paths);
  }

  path.pop();
  visited.delete(start); // Backtrack cho multiple paths
  return allPaths;
}
```

### 3. **Connected Components** - Th√†nh ph·∫ßn li√™n th√¥ng

```javascript
function countConnectedComponents(graph) {
  const visited = new Set();
  let components = 0;

  function dfs(node) {
    if (visited.has(node)) return;

    visited.add(node);
    for (let neighbor of graph[node]) {
      dfs(neighbor);
    }
  }

  for (let node in graph) {
    if (!visited.has(node)) {
      dfs(node);
      components++;
    }
  }

  return components;
}
```

### 4. **Cycle Detection** - Ph√°t hi·ªán chu tr√¨nh

```javascript
// Directed Graph
function hasCycleDirected(graph) {
  const WHITE = 0,
    GRAY = 1,
    BLACK = 2;
  const colors = {};

  function dfs(node) {
    if (colors[node] === GRAY) return true; // Back edge = cycle
    if (colors[node] === BLACK) return false; // Already processed

    colors[node] = GRAY; // Mark as processing

    for (let neighbor of graph[node] || []) {
      if (dfs(neighbor)) return true;
    }

    colors[node] = BLACK; // Mark as done
    return false;
  }

  for (let node in graph) {
    if (colors[node] === undefined) {
      if (dfs(node)) return true;
    }
  }
  return false;
}

// Undirected Graph
function hasCycleUndirected(graph) {
  const visited = new Set();

  function dfs(node, parent) {
    visited.add(node);

    for (let neighbor of graph[node] || []) {
      if (neighbor === parent) continue; // Skip parent
      if (visited.has(neighbor)) return true; // Cycle found
      if (dfs(neighbor, node)) return true;
    }
    return false;
  }

  for (let node in graph) {
    if (!visited.has(node)) {
      if (dfs(node, null)) return true;
    }
  }
  return false;
}
```

### 5. **Topological Sort** - S·∫Øp x·∫øp topo

```javascript
function topologicalSort(graph) {
  const visited = new Set();
  const stack = [];

  function dfs(node) {
    if (visited.has(node)) return;

    visited.add(node);

    for (let neighbor of graph[node] || []) {
      dfs(neighbor);
    }

    stack.push(node); // Add after processing children
  }

  for (let node in graph) {
    if (!visited.has(node)) {
      dfs(node);
    }
  }

  return stack.reverse(); // Reverse for correct order
}
```

## üî¢ Case Study: Lexicographical Numbers

B√†i to√°n th·ª© t·ª± t·ª´ ƒëi·ªÉn l√† v√≠ d·ª• ƒëi·ªÉn h√¨nh c·ªßa DFS tr√™n c·∫•u tr√∫c c√¢y ·∫£o.

### **T·∫°i sao d√πng DFS?**

```
Lexicographical order t·∫°o th√†nh c√¢y:
        Root
       /  |  \
      1   2   3 ... 9
     /|   |    \
   10 11  20   30 ...
   /|     |     \
 100 101  200   300 ...
```

### **DFS Approach:**

```javascript
function lexicalOrder(n) {
  const result = [];

  function dfs(current) {
    if (current > n) return;

    result.push(current); // Visit node

    // Duy·ªát children theo th·ª© t·ª± 0-9
    for (let i = 0; i <= 9; i++) {
      const next = current * 10 + i;
      if (next > n) break;
      dfs(next); // Go deeper
    }
  }

  // Start t·ª´ 1-9 (kh√¥ng c√≥ 0 ƒë·∫ßu)
  for (let i = 1; i <= 9; i++) {
    if (i > n) break;
    dfs(i);
  }

  return result;
}
```

### **Trace v·ªõi n=13:**

```
dfs(1):
  push(1) ‚Üí [1]
  dfs(10): push(10) ‚Üí [1,10]
  dfs(11): push(11) ‚Üí [1,10,11]
  dfs(12): push(12) ‚Üí [1,10,11,12]
  dfs(13): push(13) ‚Üí [1,10,11,12,13]
  dfs(14): 14 > 13, return
  ...
dfs(2):
  push(2) ‚Üí [1,10,11,12,13,2]
  dfs(20): 20 > 13, return
dfs(3):
  push(3) ‚Üí [1,10,11,12,13,2,3]
...

Final: [1,10,11,12,13,2,3,4,5,6,7,8,9]
```

### **Iterative Version (O(1) space):**

```javascript
function lexicalOrderIterative(n) {
  const result = [];
  let current = 1;

  for (let i = 0; i < n; i++) {
    result.push(current);

    // Try go deeper (multiply by 10)
    if (current * 10 <= n) {
      current *= 10;
    }
    // Try go right (increment)
    else {
      // Backtrack if ending with 9 or can't increment
      while (current % 10 === 9 || current + 1 > n) {
        current = Math.floor(current / 10);
      }
      current++;
    }
  }

  return result;
}
```

## üé® DFS Patterns & Templates

### **Pattern 1: Simple DFS**

```javascript
function dfs(node, visited = new Set()) {
  if (!node || visited.has(node)) return;

  visited.add(node);
  // Process node

  for (let child of node.children) {
    dfs(child, visited);
  }
}
```

### **Pattern 2: DFS with Path**

```javascript
function dfsWithPath(node, target, path = []) {
  if (!node) return false;

  path.push(node);

  if (node === target) return true;

  for (let child of node.children) {
    if (dfsWithPath(child, target, path)) return true;
  }

  path.pop(); // Backtrack
  return false;
}
```

### **Pattern 3: DFS with Return Value**

```javascript
function dfsWithReturn(node) {
  if (!node) return baseValue;

  let result = processNode(node);

  for (let child of node.children) {
    result = combineResults(result, dfsWithReturn(child));
  }

  return result;
}
```

### **Pattern 4: DFS with State**

```javascript
function dfsWithState(node, state) {
  if (!node) return;

  // Update state
  state.update(node);

  // Process
  if (satisfiesCondition(node, state)) {
    // Do something
  }

  for (let child of node.children) {
    dfsWithState(child, state);
  }

  // Restore state (backtrack)
  state.restore(node);
}
```

## üöÄ Advanced DFS Techniques

### **1. Memoization DFS**

```javascript
function dfsMemo(node, memo = new Map()) {
  if (!node) return 0;
  if (memo.has(node)) return memo.get(node);

  let result = compute(node);
  for (let child of node.children) {
    result += dfsMemo(child, memo);
  }

  memo.set(node, result);
  return result;
}
```

### **2. Multi-source DFS**

```javascript
function multiSourceDFS(sources, graph) {
  const visited = new Set();

  function dfs(node) {
    if (visited.has(node)) return;
    visited.add(node);

    // Process
    for (let neighbor of graph[node]) {
      dfs(neighbor);
    }
  }

  for (let source of sources) {
    if (!visited.has(source)) {
      dfs(source);
    }
  }
}
```

### **3. DFS with Time Stamps**

```javascript
function dfsWithTimestamps(graph) {
  const visited = new Set();
  const startTime = {};
  const endTime = {};
  let time = 0;

  function dfs(node) {
    if (visited.has(node)) return;

    visited.add(node);
    startTime[node] = ++time;

    for (let neighbor of graph[node]) {
      dfs(neighbor);
    }

    endTime[node] = ++time;
  }

  for (let node in graph) {
    if (!visited.has(node)) {
      dfs(node);
    }
  }

  return { startTime, endTime };
}
```

## üí° Tips & Best Practices

### **1. Khi n√†o d√πng DFS?**

- ‚úÖ T√¨m path/solution c·ª• th·ªÉ
- ‚úÖ Explore t·∫•t c·∫£ possibilities
- ‚úÖ Tree traversal
- ‚úÖ Backtracking problems
- ‚úÖ Topological sort
- ‚ùå Shortest path (d√πng BFS)
- ‚ùå Level-order traversal (d√πng BFS)

### **2. DFS vs BFS**

| Aspect                 | DFS                 | BFS                 |
| ---------------------- | ------------------- | ------------------- |
| **Memory**             | O(depth)            | O(width)            |
| **Find any solution**  | ‚úÖ Fast             | ‚úÖ Fast             |
| **Find shortest path** | ‚ùå No               | ‚úÖ Yes              |
| **All solutions**      | ‚úÖ Good             | ‚ùå Expensive        |
| **Deep trees**         | ‚ùå Stack overflow   | ‚úÖ Safe             |
| **Wide trees**         | ‚úÖ Memory efficient | ‚ùå Memory intensive |

### **3. Common Pitfalls**

```javascript
// ‚ùå Forget base case
function dfs(node) {
  // Missing: if (!node) return;
  dfs(node.left);
  dfs(node.right);
}

// ‚ùå Infinite recursion
function dfs(node, visited) {
  // Missing: if (visited.has(node)) return;
  visited.add(node);
  for (let child of node.children) {
    dfs(child, visited);
  }
}

// ‚ùå Not restoring state
function dfs(node, path) {
  path.push(node);
  if (isTarget(node)) return path;

  for (let child of node.children) {
    if (dfs(child, path)) return path;
  }
  // Missing: path.pop();
}
```

### **4. Optimization Tips**

```javascript
// ‚úÖ Early termination
function dfs(node, target) {
  if (node.value === target) return node; // Found!

  for (let child of node.children) {
    const result = dfs(child, target);
    if (result) return result; // Early return
  }
  return null;
}

// ‚úÖ Iterative for deep recursion
function dfsIterative(root) {
  const stack = [root];

  while (stack.length > 0) {
    const node = stack.pop();
    // Process node

    // Add children in reverse order
    for (let i = node.children.length - 1; i >= 0; i--) {
      stack.push(node.children[i]);
    }
  }
}
```

## üéØ Conclusion

DFS l√† m·ªôt thu·∫≠t to√°n c·ª±c k·ª≥ linh ho·∫°t v√† m·∫°nh m·∫Ω:

- **Strengths**: Memory efficient, good for finding any solution, natural for tree problems
- **Weaknesses**: Not optimal for shortest path, can cause stack overflow
- **Best for**: Backtracking, tree traversal, pathfinding, cycle detection

Trong b√†i to√°n Lexicographical Numbers, DFS shine v√¨ n√≥ naturally follow th·ª© t·ª± t·ª´ ƒëi·ªÉn m√† kh√¥ng c·∫ßn sort, ƒë·∫°t ƒë∆∞·ª£c O(n) time complexity y√™u c·∫ßu.

**Key takeaway**: DFS kh√¥ng ch·ªâ l√† thu·∫≠t to√°n duy·ªát ƒë·ªì th·ªã, m√† l√† m·ªôt mindset ƒë·ªÉ gi·∫£i quy·∫øt problems c√≥ structure ph√¢n c·∫•p ho·∫∑c c·∫ßn explore t·∫•t c·∫£ possibilities.
